import 'package:meta/meta.dart';

import '../common/copy_with_sentinel.dart';

/// Content block in a response message.
///
/// Response content blocks represent different types of content
/// generated by the model.
sealed class ContentBlock {
  const ContentBlock();

  /// Creates a [ContentBlock] from JSON.
  factory ContentBlock.fromJson(Map<String, dynamic> json) {
    final type = json['type'] as String;
    return switch (type) {
      'text' => TextBlock.fromJson(json),
      'thinking' => ThinkingBlock.fromJson(json),
      'redacted_thinking' => RedactedThinkingBlock.fromJson(json),
      'tool_use' => ToolUseBlock.fromJson(json),
      'server_tool_use' => ServerToolUseBlock.fromJson(json),
      'web_search_tool_result' => WebSearchToolResultBlock.fromJson(json),
      _ => throw FormatException('Unknown ContentBlock type: $type'),
    };
  }

  /// Converts to JSON.
  Map<String, dynamic> toJson();
}

/// Text content block in a response.
@immutable
class TextBlock extends ContentBlock {
  /// The text content.
  final String text;

  /// Citations supporting this text block.
  final List<Citation>? citations;

  /// Creates a [TextBlock].
  const TextBlock({required this.text, this.citations});

  /// Creates a [TextBlock] from JSON.
  factory TextBlock.fromJson(Map<String, dynamic> json) {
    return TextBlock(
      text: json['text'] as String,
      citations: (json['citations'] as List?)
          ?.map((e) => Citation.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  @override
  Map<String, dynamic> toJson() => {
    'type': 'text',
    'text': text,
    if (citations != null)
      'citations': citations!.map((e) => e.toJson()).toList(),
  };

  /// Creates a copy with replaced values.
  TextBlock copyWith({String? text, Object? citations = unsetCopyWithValue}) {
    return TextBlock(
      text: text ?? this.text,
      citations: citations == unsetCopyWithValue
          ? this.citations
          : citations as List<Citation>?,
    );
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TextBlock &&
          runtimeType == other.runtimeType &&
          text == other.text &&
          _listsEqual(citations, other.citations);

  @override
  int get hashCode => Object.hash(text, citations);

  @override
  String toString() =>
      'TextBlock(text: [${text.length} chars], citations: $citations)';
}

/// Thinking (reasoning) content block in a response.
@immutable
class ThinkingBlock extends ContentBlock {
  /// The thinking/reasoning content.
  final String thinking;

  /// Signature for the thinking block.
  final String signature;

  /// Creates a [ThinkingBlock].
  const ThinkingBlock({required this.thinking, required this.signature});

  /// Creates a [ThinkingBlock] from JSON.
  factory ThinkingBlock.fromJson(Map<String, dynamic> json) {
    return ThinkingBlock(
      thinking: json['thinking'] as String,
      signature: json['signature'] as String,
    );
  }

  @override
  Map<String, dynamic> toJson() => {
    'type': 'thinking',
    'thinking': thinking,
    'signature': signature,
  };

  /// Creates a copy with replaced values.
  ThinkingBlock copyWith({String? thinking, String? signature}) {
    return ThinkingBlock(
      thinking: thinking ?? this.thinking,
      signature: signature ?? this.signature,
    );
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ThinkingBlock &&
          runtimeType == other.runtimeType &&
          thinking == other.thinking &&
          signature == other.signature;

  @override
  int get hashCode => Object.hash(thinking, signature);

  @override
  String toString() =>
      'ThinkingBlock(thinking: [${thinking.length} chars], '
      'signature: [${signature.length} chars])';
}

/// Redacted thinking block (when thinking content is not available).
@immutable
class RedactedThinkingBlock extends ContentBlock {
  /// Opaque data for the redacted content.
  final String data;

  /// Creates a [RedactedThinkingBlock].
  const RedactedThinkingBlock({required this.data});

  /// Creates a [RedactedThinkingBlock] from JSON.
  factory RedactedThinkingBlock.fromJson(Map<String, dynamic> json) {
    return RedactedThinkingBlock(data: json['data'] as String);
  }

  @override
  Map<String, dynamic> toJson() => {'type': 'redacted_thinking', 'data': data};

  /// Creates a copy with replaced values.
  RedactedThinkingBlock copyWith({String? data}) {
    return RedactedThinkingBlock(data: data ?? this.data);
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RedactedThinkingBlock &&
          runtimeType == other.runtimeType &&
          data == other.data;

  @override
  int get hashCode => data.hashCode;

  @override
  String toString() => 'RedactedThinkingBlock(data: [${data.length} chars])';
}

/// Tool use block in a response.
@immutable
class ToolUseBlock extends ContentBlock {
  /// Unique identifier for this tool use.
  final String id;

  /// Name of the tool being used.
  final String name;

  /// Input parameters for the tool.
  final Map<String, dynamic> input;

  /// Creates a [ToolUseBlock].
  const ToolUseBlock({
    required this.id,
    required this.name,
    required this.input,
  });

  /// Creates a [ToolUseBlock] from JSON.
  factory ToolUseBlock.fromJson(Map<String, dynamic> json) {
    return ToolUseBlock(
      id: json['id'] as String,
      name: json['name'] as String,
      input: json['input'] as Map<String, dynamic>,
    );
  }

  @override
  Map<String, dynamic> toJson() => {
    'type': 'tool_use',
    'id': id,
    'name': name,
    'input': input,
  };

  /// Creates a copy with replaced values.
  ToolUseBlock copyWith({
    String? id,
    String? name,
    Map<String, dynamic>? input,
  }) {
    return ToolUseBlock(
      id: id ?? this.id,
      name: name ?? this.name,
      input: input ?? this.input,
    );
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ToolUseBlock &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name &&
          _mapsEqual(input, other.input);

  @override
  int get hashCode => Object.hash(id, name, input);

  @override
  String toString() => 'ToolUseBlock(id: $id, name: $name, input: $input)';
}

/// Server-side tool use block (e.g., web search).
@immutable
class ServerToolUseBlock extends ContentBlock {
  /// Unique identifier for this tool use.
  final String id;

  /// Name of the server tool (e.g., "web_search").
  final String name;

  /// Input parameters for the tool.
  final Map<String, dynamic> input;

  /// Creates a [ServerToolUseBlock].
  const ServerToolUseBlock({
    required this.id,
    required this.name,
    required this.input,
  });

  /// Creates a [ServerToolUseBlock] from JSON.
  factory ServerToolUseBlock.fromJson(Map<String, dynamic> json) {
    return ServerToolUseBlock(
      id: json['id'] as String,
      name: json['name'] as String,
      input: json['input'] as Map<String, dynamic>,
    );
  }

  @override
  Map<String, dynamic> toJson() => {
    'type': 'server_tool_use',
    'id': id,
    'name': name,
    'input': input,
  };

  /// Creates a copy with replaced values.
  ServerToolUseBlock copyWith({
    String? id,
    String? name,
    Map<String, dynamic>? input,
  }) {
    return ServerToolUseBlock(
      id: id ?? this.id,
      name: name ?? this.name,
      input: input ?? this.input,
    );
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ServerToolUseBlock &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name &&
          _mapsEqual(input, other.input);

  @override
  int get hashCode => Object.hash(id, name, input);

  @override
  String toString() =>
      'ServerToolUseBlock(id: $id, name: $name, input: $input)';
}

/// Web search tool result block.
@immutable
class WebSearchToolResultBlock extends ContentBlock {
  /// The tool use ID this result corresponds to.
  final String toolUseId;

  /// The search results content.
  final WebSearchResult content;

  /// Creates a [WebSearchToolResultBlock].
  const WebSearchToolResultBlock({
    required this.toolUseId,
    required this.content,
  });

  /// Creates a [WebSearchToolResultBlock] from JSON.
  factory WebSearchToolResultBlock.fromJson(Map<String, dynamic> json) {
    return WebSearchToolResultBlock(
      toolUseId: json['tool_use_id'] as String,
      content: WebSearchResult.fromJson(
        json['content'] as Map<String, dynamic>,
      ),
    );
  }

  @override
  Map<String, dynamic> toJson() => {
    'type': 'web_search_tool_result',
    'tool_use_id': toolUseId,
    'content': content.toJson(),
  };

  /// Creates a copy with replaced values.
  WebSearchToolResultBlock copyWith({
    String? toolUseId,
    WebSearchResult? content,
  }) {
    return WebSearchToolResultBlock(
      toolUseId: toolUseId ?? this.toolUseId,
      content: content ?? this.content,
    );
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WebSearchToolResultBlock &&
          runtimeType == other.runtimeType &&
          toolUseId == other.toolUseId &&
          content == other.content;

  @override
  int get hashCode => Object.hash(toolUseId, content);

  @override
  String toString() =>
      'WebSearchToolResultBlock(toolUseId: $toolUseId, content: $content)';
}

/// Web search result content.
sealed class WebSearchResult {
  const WebSearchResult();

  /// Creates a [WebSearchResult] from JSON.
  factory WebSearchResult.fromJson(Map<String, dynamic> json) {
    final type = json['type'] as String;
    return switch (type) {
      'web_search_result' => WebSearchResultSuccess.fromJson(json),
      'web_search_result_error' => WebSearchResultError.fromJson(json),
      _ => throw FormatException('Unknown WebSearchResult type: $type'),
    };
  }

  /// Converts to JSON.
  Map<String, dynamic> toJson();
}

/// Successful web search result.
@immutable
class WebSearchResultSuccess extends WebSearchResult {
  /// The search results.
  final List<WebSearchResultItem> results;

  /// Creates a [WebSearchResultSuccess].
  const WebSearchResultSuccess({required this.results});

  /// Creates a [WebSearchResultSuccess] from JSON.
  factory WebSearchResultSuccess.fromJson(Map<String, dynamic> json) {
    return WebSearchResultSuccess(
      results: (json['results'] as List)
          .map((e) => WebSearchResultItem.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  @override
  Map<String, dynamic> toJson() => {
    'type': 'web_search_result',
    'results': results.map((e) => e.toJson()).toList(),
  };

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WebSearchResultSuccess &&
          runtimeType == other.runtimeType &&
          _listsEqual(results, other.results);

  @override
  int get hashCode => results.hashCode;

  @override
  String toString() => 'WebSearchResultSuccess(results: $results)';
}

/// A single web search result item.
@immutable
class WebSearchResultItem {
  /// URL of the search result.
  final String url;

  /// Title of the search result.
  final String title;

  /// Encrypted content index for citations.
  final String? encryptedContentIndex;

  /// Page age information.
  final String? pageAge;

  /// Creates a [WebSearchResultItem].
  const WebSearchResultItem({
    required this.url,
    required this.title,
    this.encryptedContentIndex,
    this.pageAge,
  });

  /// Creates a [WebSearchResultItem] from JSON.
  factory WebSearchResultItem.fromJson(Map<String, dynamic> json) {
    return WebSearchResultItem(
      url: json['url'] as String,
      title: json['title'] as String,
      encryptedContentIndex: json['encrypted_content_index'] as String?,
      pageAge: json['page_age'] as String?,
    );
  }

  /// Converts to JSON.
  Map<String, dynamic> toJson() => {
    'url': url,
    'title': title,
    if (encryptedContentIndex != null)
      'encrypted_content_index': encryptedContentIndex,
    if (pageAge != null) 'page_age': pageAge,
  };

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WebSearchResultItem &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          title == other.title &&
          encryptedContentIndex == other.encryptedContentIndex &&
          pageAge == other.pageAge;

  @override
  int get hashCode => Object.hash(url, title, encryptedContentIndex, pageAge);

  @override
  String toString() =>
      'WebSearchResultItem(url: $url, title: $title, '
      'encryptedContentIndex: $encryptedContentIndex, pageAge: $pageAge)';
}

/// Web search error result.
@immutable
class WebSearchResultError extends WebSearchResult {
  /// Error code.
  final String errorCode;

  /// Error message.
  final String message;

  /// Creates a [WebSearchResultError].
  const WebSearchResultError({required this.errorCode, required this.message});

  /// Creates a [WebSearchResultError] from JSON.
  factory WebSearchResultError.fromJson(Map<String, dynamic> json) {
    return WebSearchResultError(
      errorCode: json['error_code'] as String,
      message: json['message'] as String,
    );
  }

  @override
  Map<String, dynamic> toJson() => {
    'type': 'web_search_result_error',
    'error_code': errorCode,
    'message': message,
  };

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WebSearchResultError &&
          runtimeType == other.runtimeType &&
          errorCode == other.errorCode &&
          message == other.message;

  @override
  int get hashCode => Object.hash(errorCode, message);

  @override
  String toString() =>
      'WebSearchResultError(errorCode: $errorCode, message: $message)';
}

/// Citation for text content.
sealed class Citation {
  const Citation();

  /// Creates a [Citation] from JSON.
  factory Citation.fromJson(Map<String, dynamic> json) {
    final type = json['type'] as String;
    return switch (type) {
      'char_location' => CharLocationCitation.fromJson(json),
      'page_location' => PageLocationCitation.fromJson(json),
      'content_block_location' => ContentBlockLocationCitation.fromJson(json),
      'web_search_result_location' => WebSearchResultLocationCitation.fromJson(
        json,
      ),
      _ => throw FormatException('Unknown Citation type: $type'),
    };
  }

  /// Converts to JSON.
  Map<String, dynamic> toJson();
}

/// Citation with character location (for plain text sources).
@immutable
class CharLocationCitation extends Citation {
  /// The cited text.
  final String citedText;

  /// The document index.
  final int documentIndex;

  /// The document title.
  final String? documentTitle;

  /// Start character offset.
  final int startCharIndex;

  /// End character offset.
  final int endCharIndex;

  /// Creates a [CharLocationCitation].
  const CharLocationCitation({
    required this.citedText,
    required this.documentIndex,
    this.documentTitle,
    required this.startCharIndex,
    required this.endCharIndex,
  });

  /// Creates a [CharLocationCitation] from JSON.
  factory CharLocationCitation.fromJson(Map<String, dynamic> json) {
    return CharLocationCitation(
      citedText: json['cited_text'] as String,
      documentIndex: json['document_index'] as int,
      documentTitle: json['document_title'] as String?,
      startCharIndex: json['start_char_index'] as int,
      endCharIndex: json['end_char_index'] as int,
    );
  }

  @override
  Map<String, dynamic> toJson() => {
    'type': 'char_location',
    'cited_text': citedText,
    'document_index': documentIndex,
    if (documentTitle != null) 'document_title': documentTitle,
    'start_char_index': startCharIndex,
    'end_char_index': endCharIndex,
  };

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CharLocationCitation &&
          runtimeType == other.runtimeType &&
          citedText == other.citedText &&
          documentIndex == other.documentIndex &&
          documentTitle == other.documentTitle &&
          startCharIndex == other.startCharIndex &&
          endCharIndex == other.endCharIndex;

  @override
  int get hashCode => Object.hash(
    citedText,
    documentIndex,
    documentTitle,
    startCharIndex,
    endCharIndex,
  );

  @override
  String toString() =>
      'CharLocationCitation(citedText: [${citedText.length} chars], '
      'documentIndex: $documentIndex, documentTitle: $documentTitle, '
      'startCharIndex: $startCharIndex, endCharIndex: $endCharIndex)';
}

/// Citation with page location (for PDF sources).
@immutable
class PageLocationCitation extends Citation {
  /// The cited text.
  final String citedText;

  /// The document index.
  final int documentIndex;

  /// The document title.
  final String? documentTitle;

  /// Start page number.
  final int startPageNumber;

  /// End page number.
  final int endPageNumber;

  /// Creates a [PageLocationCitation].
  const PageLocationCitation({
    required this.citedText,
    required this.documentIndex,
    this.documentTitle,
    required this.startPageNumber,
    required this.endPageNumber,
  });

  /// Creates a [PageLocationCitation] from JSON.
  factory PageLocationCitation.fromJson(Map<String, dynamic> json) {
    return PageLocationCitation(
      citedText: json['cited_text'] as String,
      documentIndex: json['document_index'] as int,
      documentTitle: json['document_title'] as String?,
      startPageNumber: json['start_page_number'] as int,
      endPageNumber: json['end_page_number'] as int,
    );
  }

  @override
  Map<String, dynamic> toJson() => {
    'type': 'page_location',
    'cited_text': citedText,
    'document_index': documentIndex,
    if (documentTitle != null) 'document_title': documentTitle,
    'start_page_number': startPageNumber,
    'end_page_number': endPageNumber,
  };

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PageLocationCitation &&
          runtimeType == other.runtimeType &&
          citedText == other.citedText &&
          documentIndex == other.documentIndex &&
          documentTitle == other.documentTitle &&
          startPageNumber == other.startPageNumber &&
          endPageNumber == other.endPageNumber;

  @override
  int get hashCode => Object.hash(
    citedText,
    documentIndex,
    documentTitle,
    startPageNumber,
    endPageNumber,
  );

  @override
  String toString() =>
      'PageLocationCitation(citedText: [${citedText.length} chars], '
      'documentIndex: $documentIndex, documentTitle: $documentTitle, '
      'startPageNumber: $startPageNumber, endPageNumber: $endPageNumber)';
}

/// Citation with content block location.
@immutable
class ContentBlockLocationCitation extends Citation {
  /// The cited text.
  final String citedText;

  /// The document index.
  final int documentIndex;

  /// The document title.
  final String? documentTitle;

  /// Start content block index.
  final int startBlockIndex;

  /// End content block index.
  final int endBlockIndex;

  /// Creates a [ContentBlockLocationCitation].
  const ContentBlockLocationCitation({
    required this.citedText,
    required this.documentIndex,
    this.documentTitle,
    required this.startBlockIndex,
    required this.endBlockIndex,
  });

  /// Creates a [ContentBlockLocationCitation] from JSON.
  factory ContentBlockLocationCitation.fromJson(Map<String, dynamic> json) {
    return ContentBlockLocationCitation(
      citedText: json['cited_text'] as String,
      documentIndex: json['document_index'] as int,
      documentTitle: json['document_title'] as String?,
      startBlockIndex: json['start_block_index'] as int,
      endBlockIndex: json['end_block_index'] as int,
    );
  }

  @override
  Map<String, dynamic> toJson() => {
    'type': 'content_block_location',
    'cited_text': citedText,
    'document_index': documentIndex,
    if (documentTitle != null) 'document_title': documentTitle,
    'start_block_index': startBlockIndex,
    'end_block_index': endBlockIndex,
  };

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ContentBlockLocationCitation &&
          runtimeType == other.runtimeType &&
          citedText == other.citedText &&
          documentIndex == other.documentIndex &&
          documentTitle == other.documentTitle &&
          startBlockIndex == other.startBlockIndex &&
          endBlockIndex == other.endBlockIndex;

  @override
  int get hashCode => Object.hash(
    citedText,
    documentIndex,
    documentTitle,
    startBlockIndex,
    endBlockIndex,
  );

  @override
  String toString() =>
      'ContentBlockLocationCitation(citedText: [${citedText.length} chars], '
      'documentIndex: $documentIndex, documentTitle: $documentTitle, '
      'startBlockIndex: $startBlockIndex, endBlockIndex: $endBlockIndex)';
}

/// Citation from web search result.
@immutable
class WebSearchResultLocationCitation extends Citation {
  /// The cited text.
  final String citedText;

  /// Encrypted index for the citation.
  final String encryptedIndex;

  /// Title of the source.
  final String? title;

  /// URL of the source.
  final String? url;

  /// Creates a [WebSearchResultLocationCitation].
  const WebSearchResultLocationCitation({
    required this.citedText,
    required this.encryptedIndex,
    this.title,
    this.url,
  });

  /// Creates a [WebSearchResultLocationCitation] from JSON.
  factory WebSearchResultLocationCitation.fromJson(Map<String, dynamic> json) {
    return WebSearchResultLocationCitation(
      citedText: json['cited_text'] as String,
      encryptedIndex: json['encrypted_index'] as String,
      title: json['title'] as String?,
      url: json['url'] as String?,
    );
  }

  @override
  Map<String, dynamic> toJson() => {
    'type': 'web_search_result_location',
    'cited_text': citedText,
    'encrypted_index': encryptedIndex,
    if (title != null) 'title': title,
    if (url != null) 'url': url,
  };

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WebSearchResultLocationCitation &&
          runtimeType == other.runtimeType &&
          citedText == other.citedText &&
          encryptedIndex == other.encryptedIndex &&
          title == other.title &&
          url == other.url;

  @override
  int get hashCode => Object.hash(citedText, encryptedIndex, title, url);

  @override
  String toString() =>
      'WebSearchResultLocationCitation(citedText: [${citedText.length} chars], '
      'encryptedIndex: [${encryptedIndex.length} chars], '
      'title: $title, url: $url)';
}

bool _listsEqual<T>(List<T>? a, List<T>? b) {
  if (a == null && b == null) return true;
  if (a == null || b == null) return false;
  if (a.length != b.length) return false;
  for (var i = 0; i < a.length; i++) {
    if (a[i] != b[i]) return false;
  }
  return true;
}

bool _mapsEqual<K, V>(Map<K, V>? a, Map<K, V>? b) {
  if (a == null && b == null) return true;
  if (a == null || b == null) return false;
  if (a.length != b.length) return false;
  for (final key in a.keys) {
    if (!b.containsKey(key) || a[key] != b[key]) return false;
  }
  return true;
}
